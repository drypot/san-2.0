

산 기술 설명서
1995.02.16
박규현
--------------

   ** 워드 프로세서도 만들어 두었던 설명서의 일부분입니다.
   차례나 장 번호, 부록이 빠져있습니다. macro 디렉토리의 소스,
   테이블 화일들을 출력해 놓고 보시면서 읽어 주십시요.

   이 글은 산 입출력 시스템의 구성을 설명한다. 에디터 사용시 도움을 줄
   수 있는 화면 처리 방식, 키보드 입력 방식, 문자 생성 방식, 매크로
   사용방식등에 대한 내용이 기술되어있다. 설명서의 크기를 줄이기
   위해서 이 글을 읽는 이의 PC 내부 구조에 대한 약간의 이해와, C 언어
   프로그래밍의 기초 지식을 전제로 한다.

   일반 사용자가 읽기에는 이해하 기 힘들거나 불필요한 내용이 있을
   것이다. 하지만 사용 중 의문점을 없애기 위해 참조 할 만 하다.


화면 출력
---------

한글 출력 방식

   산은 한글 텍스트 처리 능력이 있다. 현재 사용되고 있는 대부분의
   비디오 출력장치들이 한글 처리 기능을 제공하고 있지 않기 때문에,
   산에서는 그래픽 출력 상태에서 소프트웨어 적으로 한글을 그려서
   표시하고 있다. 비슷한 방법으로 한글과 특수문자도 자체적으로
   출력하는 방식을 택하고 있다. 이렇게 문자들을 소프트웨어 방법으로
   출력할 때는 사용자가 보유하고 있는 출력장치에 따른 화면 출력
   드라이버와 글꼴이 필요하다.

화면 출력 드라이버

   도스용 산의 과거 판은 다양한 외부 화면 출력 드라이버를 지원했으나,
   도스용 산의 32비트 판부터 외부 화면 출력 드라이버를 지원하지 않고,
   VGA에서만 출력이 가능하다.

화면 출력 글꼴

   글꼴은 실행화일 내부에 들어있을 수도 있다. 산에서는 사용자가 자신의
   취향에 맞는 글꼴 을 선택할 수 있게 하기 위해서 이 글꼴 화일들을
   실행 화일 외부에 따로 두고 있으며, 원하는 글꼴 화일들의 이름을
   환경 설정 화일에서 지정함으로써 글꼴을 선택할 수 있다. 화면 출력용
   글꼴은 5 가지 종류가 있다. 각각 한글 출력용, 알파벳 출력용, 삼보
   그림문자 출력용, 특수 문자 출력용, 한자 출력용이다. 한자 출력
   화일이 지정되어 있지 않으면, 한자 코드를 한글로 변환해서 출력한다.

추가 글꼴

   산 꾸러미에는 기본적으로 각각 한 종류의 자형들만이 포함되어 있다.
   산에서 사용되는 비트맵 방식의 글꼴은 벡터 방식 글꼴에 비해 비교적
   제작이 쉽기 때문에, PC 통신 서비스 자료실 등에서 글꼴을 쉽게 구할
   수 있다.


키보드 입력
-----------

가상키

   입력부 프로그래밍 시 가장 큰 문제는 각 운영체제가 응용프로그램에
   제공하는 글쇠 정보가 제 각각이라는 것이다. 또, 지금 사용되고 있는
   103키 키보드가 현존하는 유일한 키보드가 아니다. 결국 하드웨어나
   소프트웨어 환경의 변화에 대한 입력 처리 방식의 수정 요구를 완충하기
   위해서 논리적인 가상키라는 것을 정의해 사용한다.

   가상키는 입력 시스템의 최하위 계층에서 생성되어 모든 상위 계층에서
   사용되는 키 처리 개념이다. 가상키는 운영환경별로 제작된 키보드
   드라이버에 의해서 생성된다. 상위 계층은 입력 데이터에 있어서는
   환경에 독립적이다. 가상키 코드는 운영환경이나 기기의 사용에 따라
   추가될 수 있다.

   가상키는 특정 언어에 구에 받지 않도록 정의되었다. 가상키 정의는
   문자 입력용 키에 대한 정의를 포함하고 있지만, 이 문자 입력용 키는
   한 언어에 구속적인 이름 갖지 않는다. 이 키들은 행과 열에 따라 A0,
   A1, A2, ..., B0, B1, B2, ..., C0, C1, C2, ... 등의 이름을 갖는다.
   이 가상키들에 문자 의미를 부여하는 것은 입력 시스템 상위 구조의
   역할이다.

   가상키는 당장 요구되는 문제를 해결하기 위해 103 키보드를 기준으로
   정의되어 있고, 기능별로 구분되어 있다. 새로운 키보드 시스템에서의
   사용도 고려해서 정의되어 있다.

   가상키 이름은 키 프로그래밍의 키 작동 수식에 사용된다. 매크로
   컴파일러는 이 키 이름을 해당하는 가상키 코드로 변환한다. 편리를
   위해서 매크로 컴파일러에서는 가상키에 대해 별명을 사용할 수 있고,
   C0, C1 등의 생소한 이름 대신 'A', 'S' 등의 이름을 사용할 수 있다.
   기본으로 설정되어 있는 별명은 103키 키보드에 인쇄되어 있는 기능키
   명칭과, 쿼티 영문자판에 해당하는 문자 명으로 되어 있다.

운영 체제나 그래픽 인터페이스에서 말하는 가상키와의 차이

   최근 대부분 그래픽 인터페이스 환경에서는 자신의 환경에 맞게 설계된
   프로그램에 가상키 (Virtual Key) 처리 기능을 제공한다. 이러한 운영
   환경에서 제공하는 가상키 기능은 하드웨어에 독립적인 프로그램 개발을
   돕기위한 것이다. 산에서 가상키는 하드웨어 독립적인 프로그램 개발을
   위한 것이기 보다는 운영체제등의 소프트웨어 환경 독립적인 프로그램
   개발을 위한 것이다.


가상키 이름 명명법

   가상키 리스트는 한 행 당 2개 또는 3개의 필드로 구분된다. 처음에는
   가상키의 이름이 나오며 이후 해당하는 코드가 16진수 형태로 기록되어
   있다. 필요에 따라 가상키 이름이 자판에 인쇄된 이름과 차이가 있을 때
   사용의 편리를 위해서 딴이름을 붙일 수 있도록 했다. 이것이 3 개의
   필드를 갖는 행의 2번째 필드 값이다.

   가상키는 문자 입력키에 대해서 특정 언어에 구애받는 이름을 짓지
   않았다. 문자 키를 이용해서 입력될 문자를 생성하는 과정은 가상키에서
   몇 단계의 처리를 거쳐 이루어진다. 결과로, 문자 입력키에는 키의
   위치에 따라 세로 좌표는 알파벳으로 가로 좌표는 수치로 하는 키
   이름을 갖는다. 원 좌표 이름을 키 작동 수식에서 그대로 사용하는데는
   어려움이 있기 때문에, 편의를 위해서 쿼티 자판 기준으로 문자
   입력키에 딴이름을 붙여 두었다.

   가상키 이름은 알파벳, 숫자와 밑줄 문자로 구성된다. 알파벳은 모두
   소문자를 사용한다. 키 이름은 알파벳으로만 시작한다. 기호나 숫자를
   위한 키를 표시하기 위해서 기호 이름의 철자를 그대로 사용하는 것을
   기본으로 했다. 편의를 위해서 기호를 바로 키 이름으로 사용 하는
   방법을 딴이름을 통해서 제공하는데 키 이름으로 사용될 수 없는 기호,
   숫자의 경우는 따옴표로 묶어서 표시한다. 키 작동 수식에서도 따옴표로
   기호를 묶어서 표시하는 방법을 사용할 수 있다.

   가상키 리스트는 부록에 실려 있다.


키보드 드라이버

   입력 시스템의 최하위 계층에서 하드웨어 정보를 가상키 정보로
   변환하는 기능을 하는 것이 키보드 드라이버이다. 산 32bit 판에서는
   외부 드라이버 형식으로 제공하지 않고, 실행화일 속에 포함되어 있다.

   도스 환경에서는 응용프로그램에 충분한 기능의 키보드 처리 서비스를
   하지 않는다. 당장 한영 키 처리를 지원하지 않기 때문에 이 키를 한영
   전환에 사용할 수 없다. 도스용 키보드 드라이버는 사용자가 보유하고
   있는 103키 키보드의 기능을 모두 활용할 수 있도록 만들어 졌다.

   키보드 드라이버는 글쇠를 누르는 동작, 떼는 동작을 구분하며, 한자,
   한영 글쇠를 포함한 모든 쉬프트 글쇠의 정보를 제공한다. 한번의 키
   동작에 대해서 6 바이트의 정보를 만들어 낸다. 2바이트의 가상키
   코드와 2바이트의 쉬프트 정보, 2바이트의 토글 정보이다.

키 해석기

   키 해석기는 연속적으로 입력되는 키열을 매크로 컴파일러가 출력한
   이진 코드 안의 키정의 데이터와 대조한다.

   입력된 키열이 키정의 데이터에 존재하면 내부 인터프리터 통해서 해당
   매크로 펑션을 수행한다.

   존재하지 않고, 키가 문자영역의 가상키라면 문자 생성과정을 거친다.

문자 입력

   문자 입력 과정에서는 문자 영역에 속하는 가상키 값을 이용해서 적절한
   문자 코드를 생성한다.

   두벌식과 세벌식, 쿼티와 드보락 자판과 같이 한 언어에 대해서
   여러개의 자판 배열이 가능하다. 내부에는 각 자판 별로 문자 생성기가
   존재하는 것이 아니고, 언어별로 하나의 문자 생성기가 존재하며,
   가상키를 언어별 문자 생성기 입력 코드로 변환해서 문자 생성기에
   전달한다. 단계적으로 좀더 자세히 설명하면.

   가상키 코드는 문자 생성기 입력 코드로 변환 된다. 이때 사용되는 매핑
   테이블이 meta code page 이다. meta code page에는 적절한 문자
   생성기의 ID, 자판 이름 문자열, 그리고 문자 생성기가 사용할 문자
   영역 가상키에 대응하는 문자 생성기 입력 코드가 들어 있다. 에디터
   기동중에는 여러개의 meta code page 가 적재 될 수 있다. 적재할 meta
   code page 는 환경 설정 화일의 meta_code_page 항목과 함께 나열
   되어야 한다. 여러개의 meta code page 가 적재 되었을 경우
   meta_code_page_next 함수를 수행하면 다음 meta code page 를 사용하게
   된다. 일반적으로 이 함수는 shift-space 키열에 의해서 호출된다. 이
   키열은 일반적으로 한영 전환으로 알려져 있지만, 멈밀히 말해 meta
   code page 를 전환하는 것이며, 환경 설정에 따라 두벌식과 세벌식간의
   전환에도 사용될 수 있다.

   한글과 같은 경우는 소릿값의 조합을 거쳐야 하나의 문자가 생성된다.
   즉, 단순한 가상키와 문자의 맵핑을 통해서는 문자를 만들어 내는데
   부족하다. 이 문제를 해결하기 위해서 언어 별로 문자 생성기가
   존재한다. 문자 생성기는 meta code page 를 통해 만들어진 입력 코드를
   가지고 문자를 조합한 후 coder_queue에 적재한다.

매크로 실행

   산은 사용자의 키 입력에 따른 작동방식을 임의로 정의할 수 있는
   기능을 제공한다. 첫 단계로 일정한 키열에 대해 수행할 함수를 정의할
   수 있고, 더 낳아가 기본으로 정의되어있는 함수 외에 사용자가 함수를
   프로그래밍 할 수 있다. 이렇게 만들어진 키정의 리스트와 사 용자
   함수는 매크로 컴파일러에 의해 번역되어 에디터 실행 중 판독할 수
   있는 binary pseudo code로 만들어진다. 매크로 프로그래밍은 독립된
   장으로 설명한다.

작업 영역과 화일

   화일 처리와 작업 영역 처리는 별개이다.

   편집 작업을 하기 위해서는 새로운 작업 영역을 만들어야 한다. 이 작업
   영역에서는 화일을 읽어 들일 수 있고, 편집해서 저장하거나 버릴 수
   있다. 화일을 읽기 위해서는 반드시 새 작업 영역을 할당 받은 후, 작업
   영역에 화일을 읽어 들인다. 새로 작업 영역이 열린 상태는 아무 내용도
   들어가 있지 않는 상태다. 새 작업 영역에는 화일이 지정되어 있지 않기
   때문에, 새 작업영역에서 편집 작업을 수행한 후에 결과를 저장하려면
   화일 이름을 지정해야 한다. 화일을 수정한 후 작업 영역을 닫으려 했을
   경우, 화일의 저장 여부를 확인한다.


매크로 프로그래밍
-----------------

   산에서는 사용자의 입력에 따른 편집 절차를 사용자 임의로 프로그래밍
   할 수 있는 기능을 제공한다. 이것을 매크로 프로그래밍이라 하며,
   사용자 펑션 프로그래밍과, 키 프로그래밍으로 크게 나눈다.

   프로그래밍된 소스 코드는 매크로 컴파일러에 의해 binary pseudo
   code로 만들어 지며, 에디터 안에 있는 psedo code interpreter에
   의해서 수행된다.

   이 장에서는 펑션 프로그래밍에 사용되는 언어의 문법과, 키
   프로그래밍에 사용되는 문법을 설명한다. 이후 단순히 프로그래밍이라
   칭하면 펑션 프로그래밍과 키 프로그래밍을 함께 의미 한다. 특히
   이장에서는 용어의 확실한 이해가 필수적이다.

   기본 펑션 리스트는 부록에 있다.


용어 설명

   텍스트 처리 언어 : 함수 프로그래밍에 사용되는 언어 (Text Processing
   Language). 종종 티피엘(TPL)로 언급.

   함수 : 편집 기능 수행의 단위. 모든 함수는 구분되는 이름을 가짐

   기본 함수 : 기본으로 제공되는 단순한 기능의 함수

   사용자 정의 함수 : 새로운 기능을 구현하기 위해서 기본 함수를
   사용해서 작성되는 함수

   추가 함수 : 사용자 정의 함수 형식으로 만들어지나 제작자가 미리
   만들어 배포하는 함수

   함수 프로그래밍 : 티피엘을 통해서 사용자 정의 함수를 만드는 과정

   키 워드 : 티피엘 문법 상 미리 정의되어 있는 단어.

   쉬프트 키 : 보통 누르고 있는 동안 다른 키를 누르면 새로운 동작을
   하게 하는 키들로 쉬프트키나 컨트롤키, 알트키 등. 단, 쉬프트키,
   컨트롤키, 알트키를 나누어 설명하는 부분에서의 쉬프트키는 'shift' 라
   인쇄되어져 있는 키

   키 누름 : 에디터 실행중 키보드의 키를 누르는 작업

   키 뗌 : 에디터 실행중 키보드의 눌렀던 키를 떼는 작업

   키 작동 : 에디터 실행중 키보드를 누르거나 떼는 작업

   키 입력 : 키 작동과 키가 작동되는 순간의 쉬프트키 상태를 묶은 의미.

   키열 : 연속되는 키입력


{{

   개발자 노트

   여태까지는 에디터가 제공하는 기능에 배당된 키들을 입력함으로써
   화일을 편집했다. 에디터의 편집기능은 제작당시 고정된 작동방식
   때문에 제약을 받을 수밖에 없었다. 아주 약간의 작동방식 변경에도
   에디터의 소스 코드를 수정하고 재 컴파일 하는 작업이 필요했다.
   더구나 이러한 작업은 사용자들에게는 전혀 불가능했다. 아마추어
   프로그래머들의 에디터 제작 동기들이 대부분 자신의 입맛에 맞는
   에디터가 없어서 였다는 점을 보더라도 이것은 산의 과거 판에서 꼭
   해결되어야 할 문제 점이었다.

   사용자 입장에서 보자면, 산에서 제공하는 매크로 프로그래밍의 용도는
   다른 에디터들의 그것과 같다. 즉, 기본으로 제공되는 기능을 엮어서
   사용자 편의의 새로운 기능을 만들어 사용한다는 것이다. 매크로 수행의
   윤곽을 잡고, 컴파일러와 인터프리터의 설계, 수정을 반복하면서 이것의
   능력이 어느 정도가 되어야 하고 사용자에게 어떤 접근 방식을
   제공해야할까에 대해서 나름대로 많이 고민하고 재 설계를 반복했다.
   여기서 내가 얻은 결론은, 몇 만 줄의 복잡한 씨 코드의 기능을
   몇백개의 함수로 압축해서 제공함으로써 이 기본 라이브러리를 이용해
   사용자가 자신의 에디터를 제작 할 수 있게 한다는 것이다. 이 것은 위
   문제에 대해 내가 생각할 수 있었던 최선의 해결책이었다.

   이를 위해서 키 프로그래밍 기능을 일단 구현했다. 펑션 프로그래밍
   부분과 마찬가지로 최대한 사용자에게 자유를 부여할 수 있도록
   설계했다. 함수 부분은 가장 많이 교육되고 있는 프로그래밍 언어인 씨
   언어의 형식과 같게 했고, 기본 함수의 기능은 최대한 나누어 단순하고
   다양하도록 했다. 실제로 함수 프로그래밍에 제공되는 기본 함수들의
   이름은 산의 실제 씨 코드 함수의 이름과 같다. 그리고 이런 기본
   함수를 사용해서 구현될 수 있는 기존의 고급 기능들을 씨 언어
   코드에서 티피엘 코드로 바꾸었다. 이것이 기본 함수에 더해서 제공되는
   추가 함수들이다.

}}

{{
   매크로 컴파일러 사용법

   매크로 컴파일러(MC.EXE)는 기본 테이블과 매크로 프로그램 소스를
   컴파일해서 에디터안에 들어있는 인터프리터가 수행할 수 있는 binary
   pseudo code를 만들어 낸다. 컴파일러가 요구하는 화일은 4가지 이다.
   컴파일러에 이 4개 화일 이름을 전달하는 배치화일(MC.BAT)이 산 꾸러미
   안에 들어있다. 컴파일 시에는 항상 배치파일을 이용하도록 한다.

   함수 정의 화일과 키 정의 화일을 편집한 다음, 컴파일러를 실행시키면
   컴파일 작업을 시작하며, 컴파일도중 오류가 발생하면, 화일과 컴파일
   중이던 줄번호를 출력하며 종료한다. 작업이 정상적으로 완료되면 아무
   알림말 없이 명령행 상태로 돌아온다.

   매크로 컴파일러는 macro₩san.bin 이라는 화일을 출력한다. 이 화일에는
   키 프로그램 소스를 번역한 이진 키 테이블 데이터와, 함수 프로그램
   소스를 번역한 이진 데이터와 슈도 코드가 함께 들어있다.
}}

{{

 컴파일러 입력 화일들

 함수 리스트 화일

   이 화일 안에는 미리 정의되어 있는 기본화일에 대한 정보가 포함되어
   있다. 현재 정의되어 있는 함수 모두가 실제로 사용가능한 것은 아니다.
   사용 가능한 기본 함수에 대한 정보는 부록의 기본 함수 리스트를
   참조한다. 이 화일은 사용자가 수정해서는 안된다. 화일 이름의
   초기치는 macro₩san.fl 이다

 키 리스트 화일

   가상키 이름과 해당하는 코드에 대한 정보가 포함되어 있다. 가상키
   이름은 키 프로그래밍 시에 사용되며 컴파일러가 가상키 이름을
   해당하는 가상키 코드로 변환한다. 가상키에 대한 정보는 부록을
   참조한다. 화일 이름의 초기치는 macro₩qwerty.kl 이다

 함수 정의 화일

   사용자가 프로그래밍한 함수들을 포함하는 화일이다. 이 화일에는 이미
   작성되어 있는 추가 함수들이 들어 있다. 이 화일의 뒷 부분에 사용자
   정의 함수를 작성해 넣을 수 있다. 함수 작성에 대한 자세한 설명은 이
   장의 함수 프로그래밍을 참조한다. 화일 이름의 초기치는 macro₩san.f
   이다.

 키 정의 화일

   키 프로그램 소스를 포함하는 화일이다. 키 프로그램에 대한 자세한
   설명은 이 장 뒷부분 키 프로그래밍을 참조한다. 화일 이름의 초기치는
   macro₩san.kb 이다.

}}


함수 프로그래밍

   티피엘 프로그래밍 문법을 소개한다. 문법의 전체적인 모습은 씨 언어의
   모습과 같다. 프로그램의 예제는 sanf 화일에 들어있는 추가 함수를
   참고한다. 씨언어의 사전 지식을 전제 로 설명한다. 프로그래밍에
   경험이 없는 사용자는 사용에 어려움이 있을 수 있다.

함수 이름

   모든 함수는 각각의 이름을 갖는다. 기본 함수들의 이름은 미리
   정의되어 있으며 같은 이름을 사용자 정의 함수에 사용할 수 없다.
   이름은 알파벳과 숫자와 밑줄 문자로 구성된다. 단, 이름의 시작은
   알파벳이나 밑줄 문자가 되어야 한다. 함수 이름의 대소문자는
   구분된다. 모든 기본 함수 이름은 소문자와 밑줄 문자로 되어있다.
   사용자 추가 함수는 될 수 있으면 앞으로 만들어질 기본 함수 이름과
   중복되지 않도록 자신만의 독특한 규약을 같는 것이 좋다.

주석

   프로그램의 소스에는 주석을 넣을 수 있다. 주석에는 2 가지가 있는데
   줄의 임의의 위치에서 시작되어 줄의 끝에서 끝나는 것이 있고, 화일의
   임의의 위치에서 시작해서 임의의 위치에서 끝나는 것이 있다. 행
   주석은 '#' 문자나 '//' 문자열로 시작한다. 영역 주석은 '/*' 문자열로
   시작하고 '*/' 문자열로 끝맺음한다.

프로그램 구성

   함수 프로그램은 꼭 function 키워드로 시작되어야 하며, 이어서 함수
   정의가 나열된다.

함수 정의

   함수 정의는 함수 이름과 함수 몸체로 이루어 진다. 함수 몸체는
   중괄호로 감싸 묶는다.

함수 몸체

   함수의 실제 실행 순서를 프로그래밍 한다. 기본 함수나, 다른 사용자
   정의 함수를 호출할 수 있으며 조건문이나 반복문을 적절히 사용할 수
   있다. 함수의 몸체는 티피엘에서 의미하는 하나의 문장 또는 복수
   문장으로 구성된다.

문장

    <공백 문장>
    <함수 호출>
    <조건문>
    <반복문>
    <블럭>

공백 문장

    예: ;

함수 호출

   함수 호출은 호출될 함수 이름과 전달될 인자로 구성된다. 인자는
   괄호로 묶고 여러 인자가 있을 경우는 콤마로 구분한다. 인자가
   없더라도 괄호는 꼭 필요하다. 세미콜론으로 끝맺음한다.

블럭

   조건문이나 반복문의 수행문에서 여러 문장을 묶을 필요가 있을 때
   사용한다. 복수 문장을 중괄호로 묶어서 표현한다.

조건문

   if ( <수식> ) 문장1
   if ( <수식> ) 문장1 else 문장2

   수식은 논리 연산이나 수치연산이 가능하다. 수식의 결과가 0 이 아니면
   참으로 간주하며 수식이 참이면 문장1 을 실행한다. else 부분은
   존재하지 않아도 된다. 수식이 거짓이면, 즉 결과가 0 이면 문장2를
   수행한다.

반복문

   while ( <수식> ) 문장

   수식이 참인 동안 문장을 반복 수행한다.

수식

   상수나 함수 리턴값 또는 다른 연산의 결과에 대해서 산술 연산이나
   논리 연산을 할 수 있다. 사용되는 연산자는 다음과 같다.

   ( )  !  / * - + >= <= < > == != && ||

함수 프로그래밍의 제한

   현재 구현된 환경에서는 사용자 정의 함수로의 인자 전달이나 리턴값
   정의는 불가능 하다. 형이나, 변수 설정 기능도 지원하지 않는다.

키 프로그래밍

   키 프로그래밍은 임의의 키열과 호출될 함수 연결을 정의하는 과정이다.
   여러가지 키열이 한 함수를 호출할 수 있다. 키열의 정의에서 사용되는
   키 이름은 가상키 이름을 사용한다. 키 입력을 묘사하기 위해서 글쇠를
   누르는 작업과 떼는 작업을 구분할 수 있고, 키나 눌러지는 시점에서
   쉬프트 상태를 정밀하게 판단할 수 있다. 왼쪽 오른쪽 각각 같은 종류의
   쉬프트 키가 있는 경우 그것을 같이 묶어 생각할 수도 있고, 서로
   별개의 쉬프트 키로 생각할 수도 있다. 이 모든 것에 대한 판단이
   간단한 수식으로 가능하다. 에디터를 사용하는 과정에서 여러가지 입력
   상황을 맞게 된다. 가장 많이 사용하게 될 입력 상태는 편집 상태이다.
   이 외에도 그림 문자 선택 상태, 한자 선택 상태, 도움말 상태 등이
   있다. 키 프로그래밍에서는 이 모든 상태를 서로 나누어 처리하며, 각
   상태에서 공통으로 사 용하는 부분에 대해서는 공통 영역에 한 번만
   지정하면 된다.

키 프로그램 구조

   키 프로그램은 keybind 키워드로 시작한다. 그리고 필드 리스트가
   이어진다.

입력 상황

   프로그램에서는 field 키워드로 입력 상태를 표시한다. field 다음에는
   각 상태를 나타내는 문자열이 나오며, 공통 영역은 "common", 편집
   상태는 "edit", 특수 문자나 한자 입력 상태는 각각 "spc_sel_box", 와
   "hanja_sel_box" 이다. 에디터 수행중 각 상태에 있을 때 먼저 해당
   하는 필드 영역을 검색한 후 입력된 키열에 해당하는 데이터가 발견되지
   않았을 때는 "common" 영역을 검색하게 된다. 그러므로, "common"
   영역에 정의되어 있더라도, 각 영역에 재 정의 할 수 있다.

함수-글쇠 연결식

   각 필드 안에는 함수-글쇠 연결식이 오게 된다.

   <함수명> : 키열 수식 [ | 키열 수식 ] ;

   키열 수식은 한번 이상 올 수 있다. 한번 이상 올때는 수직바로
   구분한다. 에디터 수행중의 키 입력이 키열 수식의 조건에 맞으면
   함수명에 명시된 함수가 수행된다. 함수는 기본 함수 와 사용자 정의
   함수가 모두 가능하다. 각 필드에서 키열은 처음 함수-글쇠 연결식부터
   비교된다. 같은 수식이 여러개 있을 때는 가장 먼저 맞아 떨어지는
   키열에 해당하는 함수가 수행된다.

키열 수식

   하나의 기능을 수행하기 위해서 두번 이상의 글쇠를 누르는 작업을
   프로그래밍 할 경우가 있다. 이 때는 여러번의 키 입력에 대한 수식을
   연결해서 표현하면 된다. 키 열 수식의 최대 크기는 16 키 입력이다.
   키열 수식은 하나 이상의 키 입력 수식으로 이루어 지고, 각각의 키
   입력 수식은 콤마로 구 분된다.

키입력 수식

   하나의 키가 눌려지거나 떼어 질때마다 키 입력 신호가 발생한다. 이
   신호에는 입력 시점의 쉬프트키 상태가 함께 기록된다. 키입력 수식은
   쉬프트 수식과 키작동 수식으로 이루어 지며, 하이픈으로 연결된다.
   쉬프트 수식은 공백일 수 있으나, 키작동 수식은 반드시 명시되어야
   한다.

키 작동 수식

   키 입력 수식의 하이픈 뒤에 오게 된다. 신호의 원인이 된 가상키
   이름을 사용해서 표현하며 글쇠가 눌리는 작동은 가상키 이름만
   표시하며, 글쇠나 떼어지는 상황은 느낌표가 선행 한 글쇠 이름이 된다.

쉬프트 수식

   쉬프트 수식은 키 작동에 조건을 부여해 입력이 원하는 것이었는지 좀더
   구체화 하는데 사용된다. 같은 키 작동이라도 명시된 쉬프트 수식
   조건과 입력시의 쉬프트 상태가 다르다면 다른 입력으로 간주한다.
   산에서 사용하는 쉬프트 수식은 매우 유연하므로 또한 사용에 주의가
   필요하다.

   입력 상황과 쉬프트 수식을 비교할 때는 쉬프트 수식에 명시된 부분을
   만족하는지만 조사한 다. 즉, 쉬프트 수식이 공백일 경우, 아무런
   비교도 이루어 지지 않으며, 콘트롤 쉬프트 키에 대한 수식만 주어지게
   되면, 알트나 쉬프트 키에 대한 조사는 이루어 지지 않는다. 각 쉬프트
   키가 눌러진 조건을 명시할 때는 해당 쉬프트 키 수식을 느낌표 앞에
   적고, 키가 반드시 떼어져 있어야 하는 조건을 명시할 때는 느낌표 뒤에
   적는다. 쉬프트 수식에서 느낌 표는 한번만 올 수 있고, 없을 수도
   있다.

   예: c    csa    c!sa    ls!cars

   콘트롤 쉬프트는 c, 쉬프트는 s, 알트 쉬프트는 a 로 표시한다.
   왼쪽이나 오른쪽을 명시할 때는 각 문자 앞에 l, 이나 r 을 붙이면
   된다. 여러개의 쉬프트 조건은 사이 공백없이 연속 한다.

   예: sca  lc  rc  lcls

   주의: 앞에서 이야기 했듯이 키열이 입력 되었을 때 인터프리터는 해당
   필드의 함수-글쇠 연결식의 처음부터 조사해 내려온다. 이 수식중 PgUp
   글쇠를 눌랬을 때와 Ctrl-PgUp 을 눌렀을 때 기능을 묘사하는 수식이
   있을 경우, 전자는 -pgup, 후자는 c-pgup 으로 표현될 수 있다. 문제는
   -pgup 수식이 앞 부분에 왔을 경우 쉬프트 상황에 대해서는 전혀 비교를
   하지 않기 때문에 Ctrl-PgUp 을 입력한 상황이라도 -pgup 에 해당하는
   기능을 수행하게 된다. 이때는 명시적으로 모든 쉬프트 키가 않눌러져
   있는 조건을 표시해 주어야 하며, 바른 수식은 !sca-pgup 이 된다.


{{

입력 필드와 기본 함수

   각 입력 필드에 있을 때 인터프리터가 해석해서 수행할 수 있는 함수의
   종류들이 서로 다르다. 이동 글쇠는 대부분의 입력 필드에서 의미를
   가지나 편집기능등의 함수가 그림 문자 선택 상태에서 의미를 가질리
   만무하다. 각 필드에서 의미를 가지는 기본 함수 리스트는 기본 함수
   사전을 참조한다.

}}

